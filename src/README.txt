This project generates camera paths using a PRM in a virtual underwater world.
Katie Davis Master's Thesis April 2017


RUNNING: 
https://bitbucket.org/kddavis/prm-thesis/src
Must have:
- OpenCV installed at OPENCV_DIR (i.e. /usr/local/Cellar/opencv/2.4.13.2/include)
- GLEW installed at GLEW_DIR
- GLFW_DIR installed at GLFW_DIR
- Eigen installed at EIGEN3_INCLUDE_DIR
$ cmake .
$ make -j4


USAGE:
Generate a camera path using the rule of thirds:
./ProjF thirds 
Writes resulting file to resources/path.txt

Generate a camera path using the model normals:
./ProjF norms 

Generate a camera path using a combination of both:
./ProjF combo 

Play back a camera path:
./ProjF paths [pathFilename]
If no file name is specified it plays resources/path.txt path
Otherwise, plays back specified file 

Generate many paths at once
python ./scripy.py
Runs path generation code many times (30x for each method)
Stores paths in resources/paths/thirds /norms and /combo


NOTES:
- Thesis defense slides at https://docs.google.com/presentation/d/1XYFk2FlruCQJM8JouGjAJvXunFobJV_WPwovI26W1Vw/edit?usp=sharing
Gives some context for project & high level overview
- PRM = Probabilistic Roadmap = A robotics motion planning algorithm
- Algorith selects node to expand from, generates random node within delta of 
old node, calculates weight of this node using OpenGL & OpenCV, loops until path 
with enough nodes has been created, writes path to file
- Path of elliptical, varying radius (i.e. 25, 1x, 0.75z, +-2) set in x, z 
Camera height & pitch generated by PRM, direction set to face circle center 
- Most of the OpenGL code is in main.cpp (sorry it's giant & terrible & ugly)
- Node.cpp contains node class used in PRM (contains camera pos & dir)
Path parameters (height delta, initial direction, radius, etc.) specified here
Uses sine & cosine to gnerate position & direction vectors along circular path
- Node.h totalPathLen = number of nodes in generated path
- PRMAlg.cpp contains PRM generation code
Half of loop iterations choose from "high weight nodes" list
Other half of iterations choose random node in roadmap, must be above threshold
- ImageProcessor.cpp uses OpenCV to calculate node weights
Scene is rendered on GPU from position specified in node in main.cpp
GPU image written to framebuffer & transferred to OpenCV image format
When using model normals, scene is rendered with normals_vert.glsl with normals
facing camera (RGB), B points toward camera so B is detected in detectNormals() 
in ImageProcessor.cpp
Rule of thirds image uses bounding box tutorial 
http://docs.opencv.org/2.4/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/bounding_rects_circles.html#bounding-rects-circles
