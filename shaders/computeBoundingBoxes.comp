#version 450

// glDispatchCompute((bboxes.size() + 64 - 1) / 64, 1, 1);
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

uniform int max_index;
layout(binding = 1) uniform samplerBuffer tbo;

layout(binding = 0, std140) buffer InstanceMatrices {
    mat4 instance_matrix[];
};

layout(binding = 1, std140) buffer Indices {
    uvec4 indices[];
};

void main() {
    ivec2 threadId = ivec2(gl_GlobalInvocationID.xy);

    if (threadId.x > max_index)
        return;

    vec3 v[3], r[3];
    for (int i = 0; i < 3; i++) {
        int base = (threadId.x + i) / 4;
        int component = (threadId.x + i) % 4;
        int index = int(indices[base][component]);

        v[i] = texelFetch(tbo, 3 * index + 0).xyz;
        r[i] = texelFetch(tbo, 3 * index + 2).xyz;
    }

    vec3 a[2], b[2], c[2];
    a[0] = v[0];
    b[0] = v[1];
    c[0] = v[2];
    a[1] = a[0] - r[0] * (a[0].y / r[0].y);
    b[1] = b[0] - r[1] * (b[0].y / r[1].y);
    c[1] = c[0] - r[2] * (c[0].y / r[2].y);

    // vec3 vol_verts[6] = vec3[]{
    //     a[0], a[1], b[0], b[1], c[0], c[1]
    // };

    // vec3 m
    // for (int i = 0; i < 6; i++) {
    //     min_point = min(min_point, vol_verts[i]);
    //     max_point = max(max_point, vol_verts[i]);
    // }
    vec3 min_point = min(a[0], min(a[1], min(b[0], min(b[1], min(c[0], c[1])))));
    vec3 max_point = max(a[0], max(a[1], max(b[0], max(b[1], max(c[0], c[1])))));

    vec3 scale = max_point - min_point;
    vec3 center = (max_point + min_point) / 2.0;
    center.y -= 1.0;

    instance_matrix[threadId.x] = mat4(
        scale.x, 0, 0, 0,
        0, scale.y, 0, 0,
        0, 0, scale.z, 0,
        center, 1
    );
    // instance_matrix[threadId.x] = mat4(
    //     10, 0, 0, 0,
    //     0, 10, 0, 0,
    //     0, 0, 10, 0,
    //     0, 0, 0, 1
    // );
}