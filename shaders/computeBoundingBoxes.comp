#version 450

// glDispatchCompute((bboxes.size() + 64 - 1) / 64, 1, 1);
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

uniform uint max_index;
layout(binding = 1) uniform samplerBuffer tbo;

layout(binding = 0, std140) buffer InstanceMatrices {
    mat4 instance_matrix[];
};

layout(binding = 1, std140) buffer Indices {
    uint indices[];
};

void main() {
    ivec2 threadId = ivec2(gl_GlobalInvocationID.xy);

    if (threadId.x > max_index)
        return;

    vec3 v[3] = vec3[3](texelFetch(tbo, 3 * int(indices[threadId.x]) + 0).xyz, texelFetch(tbo, 3 * int(indices[threadId.x] + 1) + 0).xyz, texelFetch(tbo, 3 * int(indices[threadId.x] + 2) + 0).xyz);
    // vec3 n[3] = vec3[3](texelFetch(tbo, 3 * int(indices[threadId.x]) + 1).xyz, texelFetch(tbo, 3 * int(indices[threadId.x] + 1) + 1).xyz, texelFetch(tbo, 3 * int(indices[threadId.x] + 2) + 1).xyz);
    vec3 r[3] = vec3[3](texelFetch(tbo, 3 * int(indices[threadId.x]) + 2).xyz, texelFetch(tbo, 3 * int(indices[threadId.x] + 1) + 2).xyz, texelFetch(tbo, 3 * int(indices[threadId.x] + 2) + 2).xyz);

    vec3 a[2], b[2], c[2];
    a[0] = v[0];
    b[0] = v[1];
    c[0] = v[2];
    a[1] = a[0] - r[0] * (a[0].y / r[0].y);
    b[1] = b[0] - r[1] * (b[0].y / r[1].y);
    c[1] = c[0] - r[2] * (c[0].y / r[2].y);

    // vec3 vol_verts[6] = vec3[]{
    //     a[0], a[1], b[0], b[1], c[0], c[1]
    // };

    // vec3 m
    // for (int i = 0; i < 6; i++) {
    //     min_point = min(min_point, vol_verts[i]);
    //     max_point = max(max_point, vol_verts[i]);
    // }
    vec3 min_point = min(a[0], min(a[1], min(b[0], min(b[1], min(c[0], c[1])))));
    vec3 max_point = max(a[0], max(a[1], max(b[0], max(b[1], max(c[0], c[1])))));

    vec3 scale = max_point - min_point;
    vec3 center = (max_point + min_point) / 2.0;
    center.y -= 1.0;

    instance_matrix[threadId.x] = mat4(
        scale.x, 0, 0, 0,
        0, scale.y, 0, 0,
        0, 0, scale.z, 0,
        center, 1
    );
}